# blog

1. hexo generate 环境问题
    1. hexo 本身不能从命令行设置变量，改变 path
    2. 思考： 需要从模板按环境构建，几种工具：
        - ansible：最直接，然而 windows 不能安装 ansible ，放弃（使用 ansible 也太过小题大做）
        - jinja2：jinja 本身没有第一方的命令行工具，不想写 python ，放弃
        - golang template：github action 可以从命令行运行 go 脚本，基本没有依赖，不需要安装其他包，不需要做模块（懒）
            - golang template 的 name 要是 file name
                ```golang
                name := path.Base(*tmpl)
                t := template.Must(template.New(name).ParseFiles(*tmpl))
                err = t.Execute(os.Stdout, config)
                if err != nil {
                    log.Fatal(err)
                }
                ```
            - github workflow 如下
                ```yaml            
                - name: Use Go 1.16
                    uses: actions/setup-go@v1
                    with:
                    go-version: '1.16.1'
                
                - name: generate config
                    run: go run ./genconfig/main.go --env=gh-pages > _config.yml

                ```
            - windows 下 管道命令符有问题（带 BOM），make 命令也用不了，但懒得解决
2. 基础设施怎么定义
    1. 设施有：
        1. S3
        2. CloudFront
        3. Route53
        4. Certificate Manager
    2. 使用单独的库定义（考虑到以后还要留 cloudFront -> Backend 的途径）
    3. trigger -> Github 有点慢
3. 上传到 s3
    1. 首先直接命令行尝试以下
        ```
        aws s3 cp ./public s3://test.okami-ryo.xyz/ --recursive --region=ap-northeast-1
        ```
        成功
        但，url 访问 https://test.okami-ryo.xyz 返回 307 与 301 ，顺序如下：
        ![[2022-03-24-02-04-19.png]]
        原因如下：
        - s3 有地区访问 url 与全球访问url
        - s3 新建时，全球访问需要 24h 才能建立
        - CloudFront 链接到 s3 是使用 全球访问
        - CloudFront 在 us-east-1 ，全球访问访问不到其他地区的 s3

        途中又试了一下， `index.html` 和ts等文件能直接访问了，但访问文章又显示错误
    2. 隔一天后正常访问，但跳转不正常，可能是遇到 403 自动跳转到 main 导致（ hexo 不是 SPA ，但直接用了 SPA 的模板）
        查 s3 -> 原因：
        1. 设置了 403 error 返回，所有 403 都会保持 url 返回 index 200 (不是 SPA ，其实这一步不需要)
        2. cloudFront 没有去掉 index.html 的功能，只会忠实的返回源的内容
        3. s3 有去掉 index.html 的功能，仅在 webhosted 开启的时候适用（其实已开启，但现在没有开启公有访问所以无法验证）
        4. cloudFront 直接用 s3 arn 访问源，走 aws 内部网络，没有触发 website hosting
        解决方法：
        1. s3 开启website hosting ，允许 cloudFront 访问， 将索引文档定义为 index.html ， cloudFront 不用 arn 而是直接通过 webEndpoint 访问(不能使用 OIA)
        2. 使用 lambda@Edge （AWS 推荐）, 可以同时使用 OAI <- 先尝试使用这个
            [参考文献](https://aws.amazon.com/blogs/compute/implementing-default-directory-indexes-in-amazon-s3-backed-amazon-cloudfront-origins-using-lambdaedge/)
            > If you implement CloudFront in front of S3, you can achieve this by using an OAI. However, in order to do this, you cannot use the HTTP endpoint that is exposed by S3’s static website hosting feature. Instead, CloudFront must use the S3 REST endpoint to fetch content from your origin so that the request can be authenticated using the OAI. This presents some challenges in that the REST endpoint does not support redirection to a default index page.

            > CloudFront does allow you to specify a default root object (index.html), but it only works on the root of the website (such as http://www.example.com > http://www.example.com/index.html). It does not work on any subdirectory (such as http://www.example.com/about/). If you were to attempt to request this URL through CloudFront, CloudFront would do a S3 GetObject API call against a key that does not exist.


        3. 打开 s3 储存桶日志设定，给目标桶 logging.s3.amazonaws.com 访问权限
    3. 尝试手动建立 Lambda@Edge （ 新建 Lambda ，设置事件源为 Cloud Front （按提示配置 Role 权限到 Edge ），粘贴 Code ，Deploy
        1. 访问 / 结尾 url ，显示如下：
        2. 可能是 deploy code 时没有 deploy 到 Lambda@Edge ，再试
        3. 好了！
    4. 下一步：
        1. 构建后自动上传到 s3 的 github workflow
        2. 考虑 lambda@Edge 用 pulumi 代码化


参考阅读：
- Cloud Front：[指定默认根对象](https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html)：
    以下示例说明了默认根对象的工作方式。假定以下请求指向对象 image.jpg：
    ```
    https://d111111abcdef8.cloudfront.net/image.jpg
    ```
    相反，以下请求指向相同分配的根 URL 而不是特定的对象，如第一个示例中所述：
    ```
    https://d111111abcdef8.cloudfront.net/
    ```
    当您定义默认根对象时，调用分配的根的最终用户请求返回默认根对象。例如，如果您指定文件 index.html 作为您的默认根对象，请求：
    ```
    https://d111111abcdef8.cloudfront.net/
    ```
    返回值:
    ```
    https://d111111abcdef8.cloudfront.net/index.html
    ```
    但是，如果您定义默认根对象，最终用户对分配的子目录的请求不返回默认根对象。例如，假设 index.html 是您的默认根对象且 CloudFront 接收最终用户对 CloudFront 分配下的 install 目录的请求：
    ```
    https://d111111abcdef8.cloudfront.net/install/
    ```
    CloudFront 不会返回默认根对象，即使 index.html 的副本出现在install目录中。

    如果您将自己的分配配置为允许 CloudFront 支持的所有 HTTP 方法，则默认根对象适用于所有方法。例如，如果您的默认根对象为 index.php 并且您编写应用程序以将 POST 请求提交到您的根域 (http://example.com)，则 CloudFront 会将请求发送到 http://example.com/index.php。

    CloudFront 默认根对象的行为与 Amazon S3 索引文档的行为不同。当您配置 Amazon S3 存储桶作为网站并指定索引文档时，Amazon S3 将返回索引文档，即使用户请求存储桶中的子目录。（索引文档副本必须出现在每个子目录中。） 有关配置 Amazon S3 存储桶作为网站以及索引文档的更多信息，请参阅 Amazon Simple Storage Service 用户指南中的在 Amazon S3 上托管网站章节。
- S3： [配置索引文档](https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/IndexDocumentSupport.html)
    在 Amazon S3 中，存储桶是对象的平面容器。它不会像计算机上的文件系统那样提供任何分层组织。但是，您可以通过使用表示文件夹结构的对象键名创建逻辑层级结构。

    例如，考虑具有三个对象（具有以下键名）的存储桶。虽然它们没有按任何物理分层组织进行存储，但您可以从键名推断以下逻辑文件夹结构：

    sample1.jpg — 对象位于存储桶的根级。

    photos/2006/Jan/sample2.jpg — 对象位于 photos/2006/Jan 子文件夹中。

    photos/2006/Feb/sample3.jpg — 对象位于 photos/2006/Feb 子文件夹中。

    在 Amazon S3 控制台中，您还可以在存储桶中创建文件夹。例如，您可以创建名为 photos 的文件夹。您可以将对象上传到存储桶或该存储桶中的 photos 文件夹。如果您将对象 sample.jpg 添加到存储桶，则键名为 sample.jpg。如果您将对象上传到 photos 文件夹，则对象键名为 photos/sample.jpg。

    如果您在存储桶中创建了文件夹结构，则您必须在每个级别上都具有索引文档。在每个文件夹中，索引文档必须具有相同的名称，例如，index.html。当用户指定类似于文件夹查找的 URL 时，是否存在尾部斜杠将决定网站的行为。例如，以下具有尾部反斜杠的 URL 将返回 photos/index.html 索引文档。
    ```
    http://bucket-name.s3-website.Region.amazonaws.com/photos/
    ```
    但是，如果您从之前的 URL 排除了尾部斜杠，则 Amazon S3 将首先在存储段中查找数据元 photos。如果未找到 photos 对象，它将搜索索引文档 photos/index.html。如果找到该文档，则 Amazon S3 将返回 302 Found 消息并指向 photos/ 密钥。对于对 photos/ 的后续请求，Amazon S3 将返回 photos/index.html。如果未找到索引文档，Amazon S3 将返回错误。


# AWS
1. KMS: 创建 key
2. Secrets Manager: 创建密钥
3. ACM: 创建证书

helm bitnami kafka chart, 创建外部访问 + ELB + DNS

1. k8s 集群中，需要LB建好后才能知道地址
2. Bitnami/chart/kafka 通过哨兵，获得 lb 地址，
3. ELB 与 DNS 照老路用 Annotation 创建


### vscode memo
paste images
- install [vscode-paste-image](https://github.com/mushanshitiancai/vscode-paste-image)

    For pasting images from clipboard you can install and use vscode-paste-image. Thanks to VSCode Marketplace and the author of vscode-paste-image 💙.

    Example of settings.json for embedding images using `![[2020-08-12-20-11-46.png]]` format and saving them in Attachments folder automatically:

    ```json
    {
    "pasteImage.insertPattern": "![[${imageFileName}]]",
    "pasteImage.path": "${projectRoot}/Attachments"
    }
    ```

    After configuring vscode-paste-image extension, just copy some image and execute Paste image from the command palette and you are good to go 👍. You can create a shortcut for this command as well!

However, it could pastes, but configure failed.

Reason: another extension called hexo-utils using same command, with same effect as pasting image.
But that extension could not accept this config.
So, uninstall it, done.