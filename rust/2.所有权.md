# 所有权

借用，切片，内存布局

rust 通过所有权系统管理内存，在编译时完成检查工作。

- Rust 中每个值都有对应的变量作为其**所有者**
- 在同一时间内，值有且仅有一个所有者
- 所有者离开自己作用域时，值自动被销毁

rust 默认不进行深拷贝操作，约等于浅拷贝，但第一个变量会被无效，因此更应称之为 move

trait：
- Copy：可以拷贝，不会移动
- Drop：会直接移动

将变量传入函数会导致移动或复制，与赋值语句相同
将变量从函数中返回也会导致移动或复制

总结：赋值时发生所有权转移

> 其实跟 C++ 一样出入函数复制， 不过引用类型自动使用了移动语义

## 引用（借用）

`&String` , `&s1`
不转移所有权, 离开函数作用域时不会析构

但借用不能修改值

## 可变引用

`arg_s: &mut String` , `&mut s1` 

对于特定作用域来说，一次只能声明一个可变引用
避免造成数据竞争（否则会有两个地方可以改同一个值）


拥有不可变引用时不能创建可变引用

函数返回内部变量的引用会在函数末尾被销毁，形成悬垂引用，被 rust 检出
可直接返回该值

> 等价于函数末尾返回右值引用


## 引用规则总结

1. 任意时刻，只能拥有一个可变引用，或多个不可变引用
2. 引用总是有效的

## 切片


# 枚举与模式匹配

match 必须穷举所有可能

if let == match {
    ... => ...;
    _ => (),
}
